# CheatSheet - Two pointers, Sliding window

## 공통원소 구하기
###### 두개의 집합이 주어지면 두집합의 공통 원소를 오름차순으로 출력한다.
### 구현 포인트
- 코딩 인터뷰에서 손코딩 문제로 나오기도 함.
- Array.sort()
- 배열의 인덱스를 가리키는 p1, p2를 만들고
- 각 배열을 정렬하여 p1, p2의 크기를 비교하며 같은 원소가 있는지 검사한다.

## 최대 매출
###### n일 동안의 매출기록을 주고 연속된 k일 동안의 최대 매출액이 얼마인지 구하라고 했습니다.
###### 연속된 3일간의 최대 매출액은 11+20+25 = 56만원입니다. 최대 매출액을 출력해주세요.
### 구현 포인트
- 이중 for문을 사용해서 구해보니 time exceed가 발생했다. 이중 for 문은 3의 n승이 반복되기 때문이다.
- 이 문제는 필요한 크기의 "Window"를 만들어 밀고 나아가듯이 풀어야 한다.
- 미리 sum 을 구해두고 한칸 이동한 값을 더하고, 한칸 이동하여 빠진 값을 빼면 된다.
- (k=window size) sum + arr[i] - arr[i-k]

## 연속부분수열
###### 수열에서 연속 부분수열의 합이 특정숫자가 되는 경우가 몇 번 있는지 구하는 프로그램을 작성하세요.
### 구현포인트
- 이중 for 문을 사용하는 경우 o(n^2)이 되므로 timeout이 된다.
- 최대 매출 문제와 비교해서 sliding window의 크기가 계속 변화하는 문제
- 투포인터, sliding window 를 함께 사용해야 한다.
- sum의 값이 m보다 작으면, rt를 증가하여 sum 을 누적하고, m보다 작거나 같으면 왼쪽의 포인터를 증가시켜 sum을 누적하는 방법으로 해결 할 수 있다.
- 여기서, rt, lt의 로직을 생각해내는게 생각보다 시간이 많이 걸렸다.
- rt를 증가시키는 것을 큰 for 문으로 생각하고(rt를 옮기는것이 배열을 순회하는 것이므로) 배열을 순회하면서 lt의 값을 빼고 더하며 sum을 만들어낸다고 생각하면 쉽다..!
- answer 를 증가시키는 시점 또한 빼먹기 쉬운 문제이었다.


## 시간복잡도
###### 알고리즘에서 sliding window 와 투포인터를 사용하는 이유는 O(n*n) -> O(n)로 만들기 위함이다!
### for문 안의 if문이 있는 경우 시간복잡도는?
```
void Function(int n)
{
  for (int i = 0; i < n; ++i) -> n번 반복
  {
    if (n % 0) -> c1
    {
    	continue;  -> c2
    }
    // 코드 수행 -> c3
  }
}
```
- c1, c2, c3를 n번 반복 -> (c1+c2+c3)*n
- 시간복잡도에서는 상수가 무시되므로 최종적으로 O(n)이 된다.